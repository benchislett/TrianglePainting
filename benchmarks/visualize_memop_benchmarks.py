#!/usr/bin/env python3
"""
DISCLAIMER: This was generated by ChatGPT on Apr 18, 2025.

visualize_memop_benchmarks.py - Visualize Google-Benchmark CSV results for memory-oriented
image-buffer micro-benchmarks (memset, memcpy, vecadd).

Features
--------
* Accepts one or more benchmark CSV files (as generated by `--benchmark_format=csv`).
* Parses the benchmark **name** column (e.g. `"BM_vecadd_image_generic<U8>/1024"`) into
  the variables **optype**, **dtype**, and **resolution**.
* Lets you interactively select which combinations to plot via command-line flags.
* Supports either `bytes_per_second` (throughput) or `items_per_second` (ops/s).
* Produces high-quality seaborn bar charts, automatically grouping / faceting so that
  comparisons are obvious.
* Saves the figure to disk (default: *visualize_output.png*) and, unless suppressed,
  also shows it in an interactive window.

Installation
------------
```bash
python -m pip install pandas seaborn matplotlib
```

Examples
--------
```bash
# Compare vecadd throughput for all dtypes at 1024 x 1024
python visualize_benchmarks.py result.csv \
    --optypes vecadd \
    --resolutions 1024 \
    --metric bytes_per_second

# Compare memcpy vs memset for U8 across every resolution, show log-scaled y-axis
python visualize_benchmarks.py result.csv \
    --dtypes U8 \
    --optypes memcpy memset \
    --metric bytes_per_second --logy

# Overlay two different machines / builds in the same figure
python visualize_benchmarks.py buildA.csv buildB.csv \
    --label buildA buildB
```
"""
from __future__ import annotations

import argparse
import re
import sys
from pathlib import Path
from typing import Iterable, List

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# ────────────────────────────────────────────────────────────────────────────────
# Helpers
# ────────────────────────────────────────────────────────────────────────────────
_name_re = re.compile(r"BM_(?P<optype>\w+)_image_generic<(?P<dtype>\w+)>/(?P<resolution>\d+)")


def _parse_name(name: str) -> tuple[str, str, int]:
    """Return (optype, dtype, resolution) parsed from a benchmark **name** string."""
    m = _name_re.fullmatch(name)
    if not m:
        raise ValueError(f"Unrecognised benchmark name format: {name!r}")
    return m["optype"], m["dtype"], int(m["resolution"])


# ────────────────────────────────────────────────────────────────────────────────
# CLI
# ────────────────────────────────────────────────────────────────────────────────

def _cli(argv: Iterable[str] | None = None) -> argparse.Namespace:  # noqa: D401
    """Return parsed command-line arguments."""
    p = argparse.ArgumentParser(description="Visualise memory-benchmark CSV results.")
    p.add_argument(
        "csv_files",
        metavar="CSV",
        type=Path,
        nargs="+",
        help="One or more benchmark CSV files produced with --benchmark_format=csv",
    )
    p.add_argument(
        "--metric",
        choices=["bytes_per_second", "items_per_second"],
        default="items_per_second",
        help="Which column to plot on the y-axis (default: bytes_per_second)",
    )
    p.add_argument(
        "--optypes",
        metavar="OPT",
        nargs="*",
        default=None,
        help="Subset of operations to include (e.g. memset memcpy vecadd)",
    )
    p.add_argument(
        "--dtypes",
        metavar="DT",
        nargs="*",
        default=None,
        help="Subset of data types to include (e.g. U8 F32 I32)",
    )
    p.add_argument(
        "--resolutions",
        metavar="N",
        nargs="*",
        type=int,
        default=None,
        help="Subset of image edge lengths to include (e.g. 64 128 256)",
    )
    p.add_argument(
        "--label",
        metavar="RUNLABEL",
        nargs="*",
        default=None,
        help="Label(s) corresponding to each CSV file (defaults to stem of filename).",
    )
    p.add_argument(
        "--style",
        default="darkgrid",
        help="Seaborn style to apply (default: darkgrid)",
    )
    p.add_argument(
        "--palette",
        default="deep",
        help="Seaborn palette (default: deep)",
    )
    p.add_argument(
        "--title",
        default=None,
        help="Optional figure title.",
    )
    p.add_argument(
        "--output",
        default="visualize_output.png",
        help="Where to save the figure (default: visualize_output.png)",
    )
    p.add_argument(
        "--logy",
        action="store_true",
        help="Use a log scale for the y-axis (helpful for wide ranges).",
    )
    p.add_argument(
        "--no-show",
        dest="show",
        action="store_false",
        help="Suppress the interactive window (still saves the image).",
    )
    return p.parse_args(argv)


# ────────────────────────────────────────────────────────────────────────────────
# Main plotting routine
# ────────────────────────────────────────────────────────────────────────────────

def _load_csv(path: Path, run_label: str) -> pd.DataFrame:
    """Read *path* and return a tidy DataFrame with parsed benchmark metadata."""
    df = pd.read_csv(path)
    # Keep only relevant columns
    cols = [
        "name",
        "iterations",
        "real_time",
        "cpu_time",
        "time_unit",
        "bytes_per_second",
        "items_per_second",
    ]
    df = df[cols]
    # Parse metadata from name
    parsed = df["name"].apply(_parse_name).to_list()
    df[["optype", "dtype", "resolution"]] = pd.DataFrame(parsed, index=df.index)
    df["resolution"] = df["resolution"].astype(int)
    df["run"] = run_label
    return df


def _prepare_dataframe(args: argparse.Namespace) -> pd.DataFrame:
    labels: List[str]
    if args.label:
        if len(args.label) != len(args.csv_files):
            sys.exit("--label must have the same number of entries as CSV files")
        labels = args.label
    else:
        labels = [p.stem for p in args.csv_files]

    frames = [_load_csv(path, label) for path, label in zip(args.csv_files, labels)]
    df = pd.concat(frames, ignore_index=True)

    if args.optypes:
        df = df[df["optype"].isin(args.optypes)]
    if args.dtypes:
        df = df[df["dtype"].isin(args.dtypes)]
    if args.resolutions:
        df = df[df["resolution"].isin(args.resolutions)]

    if df.empty:
        sys.exit("No data left after applying filters - check your flags.")

    return df


def _choose_x_hue_facets(df: pd.DataFrame) -> tuple[str, str | None]:
    """Heuristic: return (x_variable, hue_variable) for seaborn catplot."""
    # Always use resolution as x because it has a natural ordering
    x = "resolution"
    # Decide hue: prefer dtype if >1 else optype if >1 else run if >1 else None
    for candidate in ("dtype", "optype", "run"):
        if df[candidate].nunique() > 1:
            return x, candidate
    return x, None


def _plot(args: argparse.Namespace, df: pd.DataFrame) -> None:
    sns.set_theme(style=args.style, palette=args.palette)

    x, hue = _choose_x_hue_facets(df)

    # Facet if multiple optypes and not used as hue
    facet = "optype" if df["optype"].nunique() > 1 and hue != "optype" else None
    facet_col_wrap = 3 if facet else None

    g = sns.catplot(
        data=df,
        x=x,
        y=args.metric,
        hue=hue,
        col=facet,
        col_wrap=facet_col_wrap,
        kind="bar",
        ci="sd",
        height=4,
        aspect=1.4,
        legend_out=True,
    )

    y_label = {
        "bytes_per_second": "Throughput (bytes/s)",
        "items_per_second": "Operations per second",
    }[args.metric]

    g.set_axis_labels("Resolution (pixels per side)", y_label)

    if args.logy:
        for ax in g.axes.flatten():
            ax.set_yscale("log")

    # Friendly titles
    for ax in g.axes.flatten():
        if facet:
            # Use prettier capitalisation for each subplot title
            ax.set_title(ax.get_title().replace("optype = ", "").upper())
    if args.title:
        g.fig.suptitle(args.title, fontsize=14, y=1.02)

    # Tight layout & save
    g.tight_layout()
    output_path = Path(args.output)
    g.savefig(output_path, dpi=300)
    print(f"Saved figure to {output_path.resolve()}")

    if args.show:
        plt.show()


# ────────────────────────────────────────────────────────────────────────────────
# Entry-point
# ────────────────────────────────────────────────────────────────────────────────

def main(argv: Iterable[str] | None = None):  # pragma: no cover
    args = _cli(argv)
    df = _prepare_dataframe(args)
    _plot(args, df)


if __name__ == "__main__":
    main()
